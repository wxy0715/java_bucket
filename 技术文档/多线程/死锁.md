# 死锁

## 死锁是什么？有什么危害？

### 什么是死锁？

#### 发生在并发中

#### 互不相让：当两个（或更多）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁。

### 死锁的影响

#### 死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力

#### 数据库中：检测并放弃事务

#### JVM中：无法自动处理

### 几率不高但危害大

#### 一旦发生，多是高并发场景，影响用户多

#### 整个系统崩溃、子系统崩溃、性能降低

#### 压力测试无法找出所有潜在的死锁

## 死锁的4个必要条件

### 互斥条件

### 请求与保持条件

### 不剥夺条件

### 循环等待条件

### 缺一不可，逐个分析之前的例子

## 如何定位死锁？

### jstack

#### 用Sloth或者命令行查看到java的pid

#### 执行${JAVA_HOME}/bin/jstack pid

### ThreadMXBean

## 实际工程中如何避免死锁？

### 设置超时时间

### 如果能使用同步代码块，就不使用同步方法：自己指定锁对象

### 避免锁的嵌套：MustDeadLock类

### 分配资源前先看能不能收回来：银行家算法

## 其他活性故障（又叫活跃性问题）

### 死锁是最常见的活跃性问题，不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺利执行，统称为活跃性问题

### 活锁（LiveLock）

#### 什么是活锁

##### 虽然线程并没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但是程序却得不到进展，因为线程始终重复做同样的事

##### 如果这里死锁，那么就是这里两个人都始终一动不动，直到对方先抬头，他们之间不再说话了，只是等待

##### 如果发生活锁，那么这里的情况就是，双方都不停地对对方说“你先起来吧，你先起来吧”，双方都一直在说话，在运行

##### 死锁和活锁的结果是一样的，就是谁都不能先抬头

#### 工程中的活锁实例：消息队列

##### 策略：消息如果处理失败，就放在队列开头重试

##### 由于依赖服务出了问题，处理该消息一直失败

##### 没阻塞，但程序无法继续

#### 如何解决活锁问题

##### 原因：重试机制不变，消息队列始终重试，吃饭始终谦让

##### 以太网的指数退避算法

##### 加入随机因素

##### 代码演示

### 饥饿

#### 当线程需要某些资源（例如CPU），但是却始终得不到

#### 线程的优先级设置得过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某程序始终占用某文件的写锁

#### 饥饿可能会导致响应性差：比如，我们的浏览器有一个线程负责处理前台响应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程把CPU资源都占用了，那么前台线程将无法得到很好地执行，这会导致用户的体验很差

#### 线程优先级

##### 10个级别，默认5

##### 程序设计不应依赖于优先级

##### 不同操作系统不一样

##### 优先级会被操作系统改变
