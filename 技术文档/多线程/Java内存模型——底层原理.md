# Java内存模型——底层原理

## 到底什么叫“底层原理”？ 本章研究的内容是什么？

### 从Java代码到CPU指令

- JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别，无法保证并发安全的效果一致
- 1. 最开始，我们编写的Java代码，是*.java文件
- 2. 在编译（javac命令）后，从刚才的*.java文件会变出一个新的Java字节码文件（*.class）
- 3. JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令
- 4. 机器指令可以直接在CPU上执运行，也就是最终的程序执行

### 重点向下钻研

- 转化过程的规范、原则

## 三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模型

### 容易混淆

- 三个截然不同的概念，但是很多人容易弄混

### 整体方向

- JVM内存结构，和Java虚拟机的运行时区域有关。
- Java内存模型，和Java的并发编程有关。
- Java对象模型，和Java对象在虚拟机中的表现形式有关。

### JVM内存结构

- 堆区（所有线程共享）
- 栈区（每个线程私有）：
- 方法区（所有线程共享）
- 本地方法栈（每个线程私有）
- 程序计数器（每个线程私有）

### Java对象模型

## JMM是什么

### 为什么需要JMM

- C语言不存在内存模型的概念
- 依赖处理器，不同处理器结果不一样
- 无法保证并发安全
- 需要一个标准，让多线程运行的结果可预期

### 是规范

- Java Memory Model
- 是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。
- 如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。

### 是工具类和关键字的原理

- volatile、synchronized、Lock等的原理都是JMM
- 如果没有JMM，那就需要我们自己指定什么时候用内存栅栏等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发并发程序。

### 最重要的3点内容

- 重排序
- 内存可见性
- 原子性

## 重排序

### 重排序的例子、什么是重排序

- 什么是重排序

	- 实际执行顺序和代码在java文件中的顺序不一致

### 重排序的好处：提高处理速度

- 对比重排序前后的指令优化

### 重排序的3种情况

- 编译器优化
- 指令重排序
- 内存的“重排序”

## 可见性

### 案例：演示什么是可见性问题

### 为什么会有可见性问题

- CPU有多级缓存，导致读的数据过期

	- 线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。

### JMM的抽象：主内存和本地内存

- 什么是主内存和本地内存

	- Java 作为高级语言，屏蔽了CPU cache等底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了主内存和本地内存的概念。

- 主内存和本地内存的关系

	- 1.	所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝
	- 2.	线程不能直接读写主内存中的变量,而是只能操作自己工作内存中的变量，然后再同步到主内存中
	- 3.	主内存是多个线程共享的，但线程间不共享工作内存,如果线程间需要通信，必须借助主内存中转来完成
	- 所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。

### happens-before原则

- 什么是happens-before

	- 解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看见A，这就是happens-before。

- 影响JVM重排序

	- 如果两个操作不具备happens-before，那么JVM是可以根据需要自由排序的，但是如果具备happens-before（比如新建线程时，run方法里面的语句一定发生在thread.start()之前），那么JVM也不能改变它们之间的顺序。

- Happens-Before规则有哪些？

	- 如果我们分别有操作 x 和操作 y，我们用 hb(x, y) 来表示 x happens-before y。
	- 单线程规则
	- 锁操作（synchronized和Lock）
	- volatile变量
	- 线程启动
	- 线程join
	- 传递性

		- 如果hb(A, C) 而且hb(B, C)，那么可以推出hb(A, C)

	- 中断

		- 一个线程被其他线程interrupt是，那么检测中断（isInterrupted）或者抛出InterruptedException一定能看到。

	- 构造方法

		- 对象构造方法的最后一行指令 happens-before 于 finalize() 方法的第一行指令。

	- 工具类的Happens-Before原则

		- 1.	线程安全的容器get一定能看到在此之前的put等存入动作
		- 2.	CountDownLatch
		- 3.	Semaphore
		- 4.	Future
		- 5.	线程池
		- 6.	CyclicBarrier

### volatile关键字

- volatile是什么

	- volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为。
	- 如果一个变量别修饰成volatile，那么JVM就知道了这个变量可能会被并发修改。
	- 但是开销小，相应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下才能发挥作用。

- volatile的适用场合

	- 不适用组合操作：a++
	- 适用场合1：boolean flag

		- 如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全

	- 适用场合2：作为刷新之前变量的触发器

		- 用了volatile int x后，可以保证读取x后，之前的所有变量都可见。
		- 一个实际生产中的例子

- volatile的作用：两点

	- 第一层：可见性
	- 第二层：禁止指令重排序优化

- volatile和synchronized的关系？

	- volatile在这方面可以看做是轻量版的synchronized：如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全。

- 学以致用：用volatile修正重排序问题

	- OutOfOrderExecution类加了volatile后，用于不会出现(0, 0)的情况了。

- volatile 小结

	- 1.	volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag。
	- 2.	volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。
	- 3.	volatile 只能作用于属性，我们用 volatile 修饰属性，这样 compilers 就不会对这个属性做指令重排序。
	- 4.	volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取。
	- 5.	volatile 提供了 happens-before 保证，对 volatile 变量 v 的写入 happens-before 所有其他线程后续对 v 的读操作。
	- 6.	volatile 可以使得 long 和 double 的赋值是原子的，后面马上会讲long 和 double的原子性。

### 能保证可见性的措施

- 除了volatile可以让变量保证可见性外，synchronized、Lock、并发集合、Thread.join()和Thread.start()等都可以保证一定的可见性，具体看happens-before原则的规定。

### 升华：对synchronized可见性的正确理解

- synchronized也可以达到同样的happens-before效果
- 这里关于synchronized有一个特别值得说的点，我们之前可能一致认为，使用了synchronized之后，synchronized会帮我们设立临界区，这样在一个线程操作数据的时候，另一个线程无法进来同时操作，所以保证了线程安全。其实这是不全面的，这种说法没有考虑到可见性问题。真正完整的说法是：
- synchronized不仅防止了一个线程在操作某对象时收到其他线程的干扰，同时还保证了修改好之后，可以立即被其他线程所看到。（因为如果其他线程看不到，那也会有线程安全问题）

## 原子性

### 什么是原子性

- 一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半的情况，是不可分割的。
- i++不是原子性的
- 用synchronized实现原子性

### Java中的原子操作有哪些？

- 1）除long和double之外的基本类型（int, byte, boolean, short, char, float）的赋值操作
- 2）所有引用reference的赋值操作，不管是 32 位的机器还是 64 位的机器
- 3）java.concurrent.Atomic.* 包中所有类的原子操作

### long 和 double 的原子性

- 问题描述

	- 官方文档
	- 对于 64 位的值的写入，可以分为两个 32 位的操作进行写入。读取错误
	- 使用 volatile 

- 结论

	- 在32位上的JVM上，long 和 double的操作不是原子的，但是在64位的JVM上是原子的。

- 实际开发中

	- 商用Java虚拟机中不会出现

### 原子操作+原子操作!=原子操作

- 去ATM机两次取钱是两次独立的原子操作，但是期间有可能银行卡被借给女朋友，也就是被其他线程打断并被修改。

*XMind: ZEN - Trial Version*