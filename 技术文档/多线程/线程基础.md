# 线程基础

## 实现多线程

### 错误的理解

#### 网上或书籍声称创建线程的2种或者3种或者4种方法

### 正确的理解

#### Oracle官网验证

#### 方法一：实现Runnable接口，重写run()函数，运行start()方法（代码展示）

#### 方法二：继承Thread类，重写run()函数，运行start()方法（代码展示）

#### 两种方法的对比

##### 方法1（实现Runnable接口）更好

##### 两种方法的本质对比

###### 最终调用target.run()

###### 整个run方法被重写

#### 总结：最精准的描述

##### 通常分为2类

##### 准确地讲：一种创建线程方式、两种实现执行单元的方式

### 经典错误观点

#### “线程池创建线程也算是一种新建线程的方式”

#### “通过Callable和FutureTask创建线程，也算是一种新建线程的方式”

#### “无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”

#### 定时器

#### 匿名内部类

#### lambda表达式

## 上山容易下山难

### 原理介绍

#### 使用interrupt来通知，而不是强制

### 最佳实践：如何正确停止线程

#### 通常的停止过程（无外界干涉的情况下）

##### 代码运行结束

#### 正确方法：用interrupt来请求停止线程

##### 普通情况（run方法内没有sleep或wait方法时的标准写法）

##### 线程可能被阻塞

##### 如果线程在每次工作迭代之后都阻塞（调用sleep 方法等）

##### 在while内tyr/catch会遇到的问题：线程无法停止

#### 正确停止线程的好处

### 错误的停止方法

#### 被弃用的stop、suspend和resume方法

##### 使用stop的后果

##### 关于stop的一种错误理论

##### suspend的问题

#### 用volatile设置boolean标记位

### 停止线程相关的重要函数解析

#### 中断线程

##### interrupt方法

#### 判断是否已被中断

##### static boolean interrupted()

##### boolean islnterrupted()

## 线程的6个状态（线程的生命周期）

### New已创建但还尚未启动的新线程

### Runnable可运行

### Blocked被阻塞

### Waiting等待

### Timed waiting限期等待

### Terminated终止

### 阻塞状态

#### 一般习惯而言，把Blocked(被阻塞）、Waiting(等待）、Timed_waiting(计时等待）都称为阻塞状态

#### 不仅仅是Blocked

## Thread和Object类中和和线程相关的重要方法

### wait()、notify()、notifyAll()方法

#### wait/notify/notifyAll的作用、用法

##### 阻塞阶段

##### 唤醒阶段

##### 遇到中断

#### wait直到以下4种情况之一发生时，才会被唤醒

##### 另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程；

##### 另一个线程调用这个对象的notifyAll()方法；

##### 过了wait(long timeout)规定的超时时间，如果传入0就是永久等待；

##### 线程自身调用了interrupt()

#### notify唤醒

##### notify方法只应该被拥有该对象的monitor的线程调用

##### 一旦线程被唤醒，线程便会从对象的“等待线程集合”中被移除，所以可以重新参与到线程调度当中

##### 要等刚才执行notify的线程退出被synchronized保护的代码并释放monitor

#### wait/notify/notifyAll的特点、性质

##### 用必须先拥有monitor

##### 只能唤醒其中一个

##### 属于Object类

##### 类似功能的Condition

##### 同时持有多个锁的情况

### sleep()方法详解

#### 作用

##### 我只想让线程在预期的时间执行，其他时候不要占用CPU资源

#### 不释放锁

##### 包括synchronized和lock

##### 和wait不同

#### 响应中断

##### 抛出InterruptedException

##### 清除中断状态

#### 一句话总结

##### sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态。

### join()方法

#### 作用、用法

##### 作用：因为新的线程加入了我们，所以我们要等他执行完再出发

##### 用法：main等待thread1执行完毕，注意谁等谁

#### 注意点

##### CountDownLatch或CyclicBarrier

### yield()方法

#### 作用：释放我的CPU时间片

#### 定位：JVM不保证遵循

#### yield和sleep区别：是否随时可能再次被调度

## 线程各属性

### 线程Id

### 线程名字

#### 默认名称源码分析

#### 修改线程的名字

### 守护线程

#### 作用：给用户线程提供服务

#### 特性

##### 线程类型默认继承自父线程

##### 被谁启动？

##### 不影响JVM退出

#### 守护线程和普通线程的区别

##### 整体无区别

##### 唯一区别在于JVM的离开

#### 常见面试问题

##### 守护线程和普通线程的区别

##### 我们是否需要给线程设置为守护线程？

### 线程优先级

#### 10个级别

##### 默认5

#### 程序设计不应依赖于优先级

##### 不同操作系统不一样

##### 优先级会被操作系统改变

## 线程的未捕获异常UncaughtException应该如何处理？

### 为什么需要UncaughtExceptionHandler？

#### 主线程可以轻松发现异常，子线程却不行

#### 子线程异常无法用传统方法捕获

#### 不能直接捕获的后果、提高健壮性

### 解决方案

#### 方案一（不推荐）：手动在每个run方法里进行try catch

#### 方案二（推荐）：利用UncaughtExceptionHandler

##### UncaughtExceptionHandler接口

##### 异常处理器的调用策略

##### 自己继承并实现UncaughtExceptionHandler

###### 给程序统一设置

###### 给每个线程单独设置

###### 给线程池设置UncaughtExceptionHandler

## 多线程是把双刃剑：可能导致安全、性能问题

### 线程安全问题

#### 运行结果错误（a++多线程下出现消失的请求现象，属于read-modify-write）

#### 死锁等活跃性问题（包括死锁、活锁、饥饿）

#### 对象发布和初始化的时候的安全问题

### 性能问题有哪些体现、什么是性能问题

### 为什么多线程会带来性能问题

#### 调度：上下文切换

##### 什么是上下文？

##### 缓存开销

##### 何时会导致密集的上下文切换

#### 协作：内存同步
