# Java并发——JUC全方位详解

## atomic包

### 什么是原子类，有什么作用？

### Atomic*基本类型原子类，已AtomicInteger为例

#### AtomicInteger 类常用方法

##### public final int get() //获取当前的值

##### public final int getAndSet(int newValue)//获取当前的值，并设置新的值

##### public final int getAndIncrement()//获取当前的值，并自增

##### public final int getAndDecrement() //获取当前的值，并自减

##### public final int getAndAdd(int delta) //获取当前的值，并加上预期的值

##### boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）

## 不可中断的典范

### 什么是CAS

### 案例演示

#### 两个线程竞争，其中一个落败

#### 用CAS思想实现的计数器

### 应用场景

#### 乐观锁

#### 并发容器

#### 原子类

## 以不变应万变【最便捷的并发安全之道】

### 什么是不变性（Immutable）

#### 如果对象在被创建后，状态就不能被修改，那么它就是不可变的。

#### 具有不变性的对象一定是线程安全的，我们不需要对其采取任何额外的安全措施，也能保证线程安全。

### 3种用法：修饰变量、方法、类

### 注意点

#### final修饰对象的时候，只是对象的引用不可变，而对象本身的属性是可以变化的

#### final使用原则

##### 良好的编程习惯

### 不变性和final的关系

#### 不变性并不意味着，简单地用final修饰就是不可变

#### 如何利用final实现对象不可变

## ConcurrentHashMap

### ConcurrentHashMap（重点、面试常考）

#### 为什么需要ConcurrentHashMap？

#### JDK1.7的ConcurrentHashMap实现和分析

#### JDK1.8的ConcurrentHashMap实现和源码分析

#### 组合操作：ConcurrentHashMap也不是线程安全的？

### CopyOnWriteArrayList

### 并发队列Queue（阻塞、非阻塞队列）

#### 如何选择适合自己的队列？

##### 边界

##### 空间

##### 吞吐量

### 各并发容器总结

#### java.util.concurrent包提供的容器，分为3类：Concurrent*、CopyOnWrite*、Blocking*

## 做好线程之间的协调人

### 什么是控制并发流程？

### CountDownLatch倒计时门闩

### Semaphore信号量

### CyclicBarrier循环栅栏

## 进阶必备，并发灵魂人物

### 学习AQS的思路

### 为什么需要AQS？

#### 锁和协作类有共同点：闸门

#### Semaphore和AQS的关系

#### 比喻

##### 群面、单面

#### 如果没有AQS

### AQS的作用

### AQS的重要性、地位

### AQS内部原理解析

#### state状态

#### FIFO队列

#### 获取/释放方法

### 应用实例解析

#### AQS用法

#### AQS在Semaphore的应用

## 获取子线程的执行结果【来而不往非礼也】

### Runnable的缺陷

#### 1	不能返回一个返回值

#### 2	也不能抛出checked Exception

### Callable接口

### Future类

#### Future的作用

#### Callable和Future的关系

#### Future的方法介绍

#### 用法1：线程池的submit方法返回Future对象

#### 用法2：用FutureTask来创建Future

### Future的注意点

#### 当for循环批量获取future的结果时，容易block，get方法调用时应使用timeout限制

#### Future和Callable的生命周期不能后退

## 从0到1打造高性能缓存【学以致用，直击痛点】

### 本章介绍

#### 本章中，我们将自己一步步实现一个缓存，用来使用和巩固我们之前学到过的并发知识。

#### 缓存是在实际生产中非常常用的工具，用了缓存以后，我们可以避免重复计算，提高吞吐量。

#### 使用缓存的代价是会额外占用一些内存，不过这个代价并不高，相比于收益而言，代价可以说是微不足道的，所以学好缓存是很有必要的。

#### 虽然缓存乍一看很简单，不就是一个Map吗？最初级的缓存确实可以用一个Map来实现，不过一个功能完备、性能强劲的缓存，需要考虑的点就非常多了，我们从最简单的HashMap入手，一步步提高我们缓存的性能。

### 从最简单版缓存入手——HashMap

#### 这种办法，是最初级的缓存，可以用，但是无法并发，因为线程不安全

### 并发安全要保证——引出用synchronized实现

#### 性能差

##### compute方法的synchronized关键字是必须加的，否则多个线程同时到compute的时候，由于HashMap是线程不安全的，所以如果多个线程同时put、get，会带来线程安全问题，所以这里用synchronized来保证每个时刻最多只有一个线程能访问，但是显而易见，这带来了性能问题。当多个线程同时想计算的时候，需要慢慢等待，严重时，性能甚至比不用缓存更差。

#### 代码复用能力差

##### 代码的复用能力很差，如果第二个类需要用缓存，难道要重新加一个HashMap，然后再加上compute方法吗？这样对代码的侵入性太高了，而且一旦我们的compute逻辑有变动，就要在之前使用了缓存的所有类中都一个个做出修改，违反了开闭原则，不可取。

### 给HashMap加final关键字

#### 属性被声明为final后，该变量则只能被赋值一次。且一旦被赋值，final的变量就不能再被改变。

#### 我们的类中Map的不需要可变，所以我们把它加上final关键字，增强安全性。

### 代码有重构空间——用装饰者模式

#### 代码修改

##### 我们假设ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情。

#### 缺点

##### 性能差

##### 当多个线程同时想计算的时候，需要慢慢等待，严重时，性能甚至比不用缓存更差。

### 性能待优化——引出锁性能优化经验：缩小锁的粒度

#### 当然，这样加锁虽然提高了并发效率，但是并不意味着就是线程安全的，还需要考虑到同时读写等情况，但是，其实没必要自己实现线程安全的HashMap，也不应该加synchronized，因为我们自己实现的性能远不如现有的并发集合。我们来使用ConcurrentHashMap优化我们的缓存：

### 用并发集合——引出ConcurrentHashMap

#### 代码和修改过程

##### 用ConcurrentHashMap来代替HashMap，由于ConcurrentHashMap自身是线程安全的，所以我们无需自己处理HashMap的线程安全问题，也无须手动synchronized，同时也提高了并发时的效率，因为ConcurrentHashMap的并发度远远高于synchronized修饰的HashMap。

#### 缺点

##### 在计算完成前，另一个要求计算相同值的请求到来，会导致计算两遍，这和缓存想避免多次计算的初衷恰恰相反，是不可接受的。

### 避免重复计算——引出Future和Callable的妙用

#### 动机

##### 现在不同的线程进来以后，确实可以同时计算，但是如果两个线程脚前脚后，也就是相差无几的进来请求同一个数据，那么我们来看看会出现什么问题：重复计算

##### 这个例子只有2个线程，并不可怕，但是如果是100个线程都请求同样的内容，却都需要重新计算，那么会造成巨大的浪费。

#### 改进方向

##### 前人种树，后人乘凉

### 依然存在重复的可能——更好的办法是用原子操作putIfAbsent

#### 如果有两个同时计算666的线程，同时调用cache.get方法，那么返回的结果都为null，后面还是会创建两个任务去计算相同的值。

### 计算中抛出异常——引出ExcecutionException

#### 对异常的处理

### 计算期间任务被取消——处理CancellationException

### 正确的异常处理逻辑——各司其职

#### 停止线程的正确方法

### 处理异常的正确逻辑：抛出或真正处理或复现该异常，不能自己吞掉

### 考虑“缓存污染”问题：计算失败则移除Future，增加健壮性

#### 演示缓存污染带来的问题，无论是计算错误还是被取消，都应该用cache.remove把缓存清理掉，这样后续的计算才可能成功。

### 缓存过期功能——用FutureTask的子类，为每个结果指定过期时间，并定期扫描过期的元素

#### 第二次计算设置了缓存时间，导致第三次计算需要重新计算。

#### 出于安全性考虑，缓存需要能够设置有效期，到期自动失效，否则缓存一直不失效的话，会带来很多缓存过期、不一致的问题。

### 过量的缓存需要被清理——LRU和FRU算法

### 测试缓存效果：用多种不同的线程的创建方式来创建线程

#### 用实现Runnable接口的方式和继承Thread类的方法实现线程，效果一样。

### 模拟大量请求，观测缓存效果——引出线程池相关知识、选择合适的线程数

#### 用线程池创建大量线程get，用了缓存后，总体耗时大大减少，体现了缓存的作用

### 想测并发性能，所有线程一同访问缓存——CountDownLatch

#### 前一个类存在一个问题，就是大量的请求实际上不是同时到达的，而是分先后，但是这样就没办法给缓存造成压力，我们需要真正的同一时刻大量请求到达，此时可以用CountDownLatch来实现。

### 每个线程都有存储独立信息的需求——引出用ThreadLocal、线程的各属性

#### 每个线程都想要打印当前时间

### 高并发访问时，第一次都拿不到缓存，导致打爆cpu和MySQL，造成缓存雪崩、缓存击穿等高并发下的缓存问题

#### 把缓存的过期时间设置为随机，就避免了缓存雪崩

### 总结ImoocCache的亮点和涉及的知识列表

#### 我们写一个缓存，用到了这么多的并发知识，以后有了这些知识作为储备，学习其他的优秀源码，比如Guava Cache，就容易多了。
