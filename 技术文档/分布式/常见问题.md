

# 分布式会话与单点登录

**用户登录一个系统后,其他系统无需用户名密码验证**

## 登录后生成token

```java
// 实现用户的redis会话
String uniqueToken = UUID.randomUUID().toString().trim();
redisOperator.set(REDIS_USER_TOKEN + ":" + user.getId(),uniqueToken);
```



## spring分布式会话管理

**1.引入依赖**

```xml
<!-- 引入 spring-session 依赖 -->
<dependency>
<groupId>org.springframework.session</groupId>
<artifactId>spring-session-data-redis</artifactId>
</dependency>

<!-- 引入spring安全框架 -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**2.配置**

```properties
spring.session.store-type: redis
```

**3.启动类修改**

```java
加@EnableRedisHttpSession  // 开启使用redis作为spring session
@SpringBootApplication(exclude = {SecurityAutoConfiguration.class}) // 排除security登录
```

## 会话拦截

```java
public class UserTokenInterceptor implements HandlerInterceptor {

    @Autowired
    private RedisOperator redisOperator;

    public static final String REDIS_USER_TOKEN = "redis_user_token";

    /**
     * 拦截请求，在访问controller调用之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String userId = request.getHeader("headerUserId");
        String userToken = request.getHeader("headerUserToken");
        if (StringUtils.isNotBlank(userId) && StringUtils.isNotBlank(userToken)) {
            String uniqueToken = redisOperator.get(REDIS_USER_TOKEN + ":" + userId);
            if (StringUtils.isBlank(uniqueToken)) {
                returnErrorResponse(response, IMOOCJSONResult.errorMsg("请登录..."));
                return false;
            } else {
                if (!uniqueToken.equals(userToken)) {
                    returnErrorResponse(response, IMOOCJSONResult.errorMsg("账号在异地登录..."));
                    return false;
                }
            }
        } else {
            returnErrorResponse(response, IMOOCJSONResult.errorMsg("请登录..."));
            return false;
        }

        /**
         * false: 请求被拦截，被驳回，验证出现问题
         * true: 请求在经过验证校验以后，是OK的，是可以放行的
         */
        return true;
    }

    public void returnErrorResponse(HttpServletResponse response,
                                    IMOOCJSONResult result) {
        OutputStream out = null;
        try {
            response.setCharacterEncoding("utf-8");
            response.setContentType("text/json");
            out = response.getOutputStream();
            out.write(JsonUtils.objectToJson(result).getBytes("utf-8"));
            out.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (out != null) {
                    out.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

}
```

## 单点登录CAS

**后端的不同服务主要是靠redis存储的用户登录信息判断用户是否登录,单点登录主要是在cas的登录接口登录后会生成redis用户信息然后重定向到一个单点登录系统,实现跳转不同的系统**

![image-20221213201458312](https://wxy-md.oss-cn-shanghai.aliyuncs.com/image-20221213201458312.png)



## 多网卡、容器内部署启动自动配置ip

```
/**
 * 针对多网卡、容器内部署等情况，可借助 "spring-cloud-commons" 提供的 "InetUtils" 组件灵活定制注册IP；
 *
 *      1、引入依赖：
 *          <dependency>
 *             <groupId>org.springframework.cloud</groupId>
 *             <artifactId>spring-cloud-commons</artifactId>
 *             <version>${version}</version>
 *         </dependency>
 *
 *      2、配置文件，或者容器启动变量
 *          spring.cloud.inetutils.preferred-networks: 'xxx.xxx.xxx.'
 *
 *      3、获取IP
 *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();
 */
```

## nacos动态更新配置不生效报错ExistingValue must be an instance of org.apache.ibatis.session.defaults.DefaultSqlSessionFactory

springcloud整合[nacos](https://so.csdn.net/so/search?q=nacos&spm=1001.2101.3001.7020)启动读取配置正常,但是动态更新配置不生效,也没有看到具体的报错信息只有一条ERROR日志

```
ERROR c.a.n.client.config.impl.CacheData - [fixed-127.0.0.1_8848] [notify-error] dataId=cmp-server-local.yml, group=DEFAULT_GROUP, md5=f95e93166e82d6b7d103cec47357a1c0, listener=com.alibaba.cloud.nacos.refresh.NacosContextRefresher$1@c63a539 tx=null
```

![image-20221128180942490](https://wxy-md.oss-cn-shanghai.aliyuncs.com/image-20221128180942490.png)

**和版本无关，具体错误原因我也没查到，不过解决方案debugger试出来了，配置文件中加入忽略刷新的配置**

```
# 解决修改nacos配置不能立即生效的问题
spring.cloud.refresh.never-refreshable= org.apache.ibatis.session.defaults.DefaultSqlSessionFactory
```

